## 64비트 프로세서의 이모저모

### 1. 운영모드
주변에서 많이 볼 수 있는 인텔64비트 호환 프로세서(x86-64)에는 크게 5가지 운영모드가 있다. 16bit의 '리얼모드', 32bit의 '보호모드' 64bit의 'IA-32e'모드 등등이다. 이런 운영모드가 있는 이유가 다 있다. 간단히 흐름정도 맛보고 넘어가자.

OS가 부팅되면 곧바로 64비트로 부팅 되는게 아니다. 컴퓨터가 부팅되면 우선 16bit인 리얼모드로 진입하게 된다. 이 모드에서는 BIOS기능을 사용하며 OS이미지를 디스크에서 메모리로 복사하여 보호모드로 변경하는 것과 같은 OS를 구동하기 위한 사전작업과 같은 일을 한다. 이후 보호모드는 32bit OS가 동작하는 기본 모드로서, OS의 필수 기능인 보호, 멀티테스킹, 세그먼테이션, 페이징 등의 기능을 하드웨어적으로 지원한다. IA-32e 모드는 보호 모드와 비슷한데 64bit로 동작한다.

대략적인 기능들은 아래와 같다. 
<br/>
[표 3-1] x86-64 프로세서의 운영 모드

| 운영 모드 | 설명 |
| :-------: | :--- |
| 리얼 모드 | 프로세서의 초기 상태로서 16bit 모드로 동작<br/>최대 1MB($$$ 2^{20}$$$)의 주소 공간 지원 |
| 보호 모드 | 32bit 모드로 동작하며 세그먼트, 페이징, 보호, 멀티태스킹 등의 기능 제공<br/>4GB($$$ 2^{32}$$$) 주소 공간 지원 |
| IA-32e 모드 | 32bit 호환 모드와 64bit 모드의 두 가지 서브모드로 구성<br/>16EB의 주소 공간 지원 |
| 시스템 관리 모드 | 전원 관리나 하드웨어 제어 같은 특수 가능을 제공하는 모드 |
| 가상 8086 모드 | 보호 모드 내부에서 가상의 환경을 설정하여 리얼 모드처럼 동작하는 모드 |
<br/>

x86-64 프로세서는 위와 같이 총 다섯 가지 운영 모드 지원하지만, 위 운영 모드를 모두 구현해야 OS를 개발할 수 있는건 아니다. 64 비트 OS가 반드시 지원해야 하는 모드는 **리얼모드**, **보호 모드**, **IA-32e모드 중 64비트 서브모드**이다. 나머지 다른 모드는 특수한 상황에서만 사용되므로 반드시 구현할 필요는 없다. 이제 앞으로 개발할 3개의 모드에 대해 알아보자.


#### 1-1.리얼모드
프로세서에 전원이 켜지거나 리셋이 되면 프로세서는 리얼모드로 진입한다. 리얼모드는 과거 16bit 프로세서와 동일하게 동작하며 BIOS(Basic Input Output Sysytem)의 기능을 사용할 수 있다고 했다. 이 BIOS가 부트로더 이미지를 메모리로 복사해준다.
무슨말인지는 알겠지만 뭔가 찝찝하다... 자세히 알아보자.


##### 1-1-1. BIOS와 부팅
부팅(Booting)은 PC가 켜진 후에 OS가 실행되기 전까지 수행되는 일련의 작업 과정을 의미한다. 부팅 과정 속에서 수행하는 작업에는 프로세서 초기화(멀티코어 관련 처리 포함), 메모리와 외부 디바이스 검사 및 초기화, 부트로더를 메모리에 복사하고 OS를 시작하는 과정 등이 포함된다.
이러한 PC 부팅과정 중 '하드웨어'와 관련된 작업을 BIOS가 담당하며, BIOS에서 수행하는 각종 테스트나 초기화를 POST(Power On Self Test)라 한다.

BIOS는 메인보드에 포함된 펌웨어(Firmware)의 일종으로, 말그대로 입출력을 담당하는 작은 프로그램이다. 보통 PC 메인보드의 ROM이나 플래시 메모리에 존재하며, 전원이 켜지는 동시에 프로세서가 가장 먼저 실행하는 코드이다.
BIOS는 부팅 옵션 설정이나 시스템의 전반적인 설정 값을 관리하고 OS를 실행할 수 있는 환경을 만든다. 마치 MCU에서 인터럽트, ADC를 사용하기 위해 레지스터 설정을 하는 것처럼 말이다. 지금 제작하는 OS도 BIOS의 기능을 사용하여 OS이미지를 메모리에 복사하고 GUI모드로 변환한다.

##### 1-1-2. 16bit 프로세서(8086) 그 대서사시
앞서 언급한 '과거 16bit프로세서'라는 말은 8086프로세서를 말하는데 8086프로세서를 배웠던 분이라면 16bit 프로세서임에도 불구하고 왜 $$$ 2^{20} $$$ 의 메모리 공간을 제공하는지 알 수 있을 것이다. 그래도 짚고 넘어가 보자.

80x86은 인텔이 개발한 16bit CPU이자 이들과 호환되는 프로세서들에서 사용한 명령어 집합 구조를 통칭하는 말이다. 8086은 20bit의 주소 버스를 가지고 있어 총 1MB($$$ 2^{20}=1,048,576 Byte $$$)의 물리 메모리를 다룰 수 있었다. (초기에 IBM이 RAM을 디자인 하면서 1MB에 해당하는 용량을 고정하였다.) 하지만 8086의 16bit 레지스터 만으로는 64KB($$$ 2^{16} = 65,536Byte $$$)만을 다룰 수 있었기 때문에 '세그먼테이션' 이라는 방식을 통해 메모리에 접근하게 되었다.

즉 어떤 메모리 주소에 접근하던지 제약이 없다. 제약이 없으니 한 프로그램이 동작할 때 다른 프로그램이 실행되지 못한다.

이후 286 아키텍처가 나오게 되는데 286 아키텍처는 하드웨어 수준의 메모리 보호를 할 수 있도록 보호모드를 도입하게 된다. 하지만 이러한 새로운 기능을 사용하려면 보호 모드를 위해 만들어진 새로운 운영 체제가 필요했다. 그렇다고 이전에 사용되던 x86칩에 맞춰 만들어진 소프트웨어를 버릴 수 도 없는 법... 80286은 8086으로 만들어진 운영 체제를 돌리기 위해 메모리 보호 기능을 꺼 주는 리얼 모드로 시작해야 했다. 그것이 오늘날 까지 내려오게 된것이다...

정리하자면 위의 장대한 스토리 때문에 리얼 모드라는 것이 생겼고 주된 역할은 OS이미지를 디스크에서 메모리에 복사하여 보호모드로 변경하는 것이다. 이 작업을 어셈블리어로 해야된다...


#### 1-2. 보호모드
보호모드... 보호모드가 뭐길래 아키텍처를 바꾸고 OS를 바꿔가며 만든것일까? 

앞서 말했지만 보호모드는 현대 컴퓨터에서 필수적인 기능인 보호, 멀티테스킹, 세그먼테이션, 페이징등과 같은 핵심 기능을 하드웨어적으로 지원한다. 
즉, 여러개의 프로그램을 동시에 실생시키기 위한 방법을 제공한다는 뜻이다. 여러개의 프로그램이 동시에 실행된다는 말은 메모리에 여러개의 프로그램이 올라간다는 뜻이 된다. 한 프로그램이 다른 프로그램이 쓰는 주소 공간에 접근하지 못하도록 하는 페이징 등의 보호 기능을 제공한다는 것이 보호의 의미이다.

보호 모드가 32bit가 아니다. 보호 모드에도 16bit ,32bit가 있지만 32bit 보호 모드는 인텔 80386(32비트 CPU) 이후부터 지원하게 되었는데 80386 부터 멀티프로그래밍의 기능을 제대로 지원했기 때문에 보호모드 = 32bit의 관념이 붙여졌다...

그래서 보호모드가 마치 32bit로 변환하는 과정인 것 처럼 설명되지만 사실은 프로세서를 보호모드로 동작 시키는 것은 32비트로 동작시키는 것과는 다른 개념이다.


##### 1-3. IA-32e()

그렇게 32bit 보호모드로 게임을 즐기다 보니... 더 좋은 그래픽의 게임이나 프로그램들을 다루고 싶어지게 됬다. 글서 64bit가 나오게 되는데 그냥 단순히 bit만 커짐으로 레지스터 같은 개념 빼고는 별 차이가 없다. 
그래서 이름도 IA-32e(Intel Architecture 32-bit Extension)이다.

