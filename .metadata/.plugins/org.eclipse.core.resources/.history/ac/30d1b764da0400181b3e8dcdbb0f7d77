/*
 * ConsoleShell.c
 *
 *  Created on: 2018. 1. 27.
 *      Author: Administrator
 */

#include "ConsoleShell.h"
#include "Console.h"
#include "Keyboard.h"
#include "Utility.h"
#include "PIT.h"
#include "RTC.h"
#include "AssemblyUtility.h"


// 커맨드 테이블 정의
SHELLCOMMANDENTRY gs_vstCommandTable[] =
{
		{"help", "Show Help", kHelp },
		{"cls", "Clear Screen", kCls },
		{"totalram", "Show Total RAM Size", kShowTotalRAMSize},
		{"strtod","String to Decimal/Hex Convert", kStringToDecimalHexTest },
		{"shutdown", "Shutdown And ReBoot OS", kShutdown},
		{ "settimer", "Set PIT Controller Counter0, ex)settimer 10(ms) 1(periodic)",
		                kSetTimer },
		{ "wait", "Wait ms Using PIT, ex)wait 100(ms)", kWaitUsingPIT },
	    { "rdtsc", "Read Time Stamp Counter", kReadTimeStampCounter },
		{ "cpuspeed", "Measure Processor Speed", kMeasureProcessorSpeed },
		{ "date", "Show Date And Time", kShowDateAndTime },
};

//===============================================================
// 실제 셸을 구성하는 코드
//===============================================================
// 셸의 메인 루프
void kStartConsoleShell(void)
{
	char vcCommandBuffer[ CONSOLESHELL_MAXCOMMANDBUFFERCOUNT ];
	int iCommandBufferIndex=0;
	BYTE bKey;
	int iCursorX, iCursorY;

	//프롬프트 출력
	kPrintf( CONSOLESHELL_PROMPTMESSAGE );

	while( 1 )
	{
		bKey = kGetCh();
		// Backspace 키 처리
		if( bKey == KEY_BACKSPACE )
		{
			if( iCommandBufferIndex > 0 )
			{
				// 현재 커서 위치를 얻어서 한 문자 앞으로 이동한 다음 공백을 출력하고 커맨드 버퍼에서 마지막 문자 삭제
				kGetCursor( &iCursorX, &iCursorY );
				kPrintStringXY(iCursorX-1, iCursorY, " ");
				kSetCursor( iCursorX-1,iCursorY);
				iCommandBufferIndex--;
			}
		}
		//엔터키 처리
		else if( bKey == KEY_ENTER )
		{
			kPrintf("\n");
			if( iCommandBufferIndex > 0 )
			{
				// 커맨드 버퍼에 있는 명령을 실행
				vcCommandBuffer[ iCommandBufferIndex ] = '\0';		// 커맨드가 문자열로 저장되니 널문자를 삽입해줌.
				kExecuteCommand(vcCommandBuffer);

			}

			// 프롬프트 출력 및 커맨드 버퍼 초기화
			kPrintf( "%s", CONSOLESHELL_PROMPTMESSAGE);
			kMemSet( vcCommandBuffer,'\0',CONSOLESHELL_MAXCOMMANDBUFFERCOUNT);
			iCommandBufferIndex=0;
		}
		// shift, Caps Lock, Num Lock, Scroll Lock은 무시
		else if( (bKey == KEY_LSHIFT) || (bKey == KEY_RSHIFT) || (bKey == KEY_CAPSLOCK) ||
			     (bKey == KEY_NUMLOCK) || (bKey == KEY_SCROLLLOCK) )
		{
			;
		}
		else
		{
			//TAB은 공백으로 전환
			if( bKey == KEY_TAB )
			{
				bKey=' ';
			}
			// 버퍼에 공간이 남아 있을 때만 가능 ( 그외 문자는 커맨드 버퍼에 쑤셔넣음 )
			if( iCommandBufferIndex < CONSOLESHELL_MAXCOMMANDBUFFERCOUNT )
			{
				vcCommandBuffer[iCommandBufferIndex++] = bKey;
				kPrintf("%c",bKey);
			}
		}
	}
}


// 커맨드 버퍼에 있는 커맨드를 비교하여 해당 커맨드를 처리하는 함수를 수행
void kExecuteCommand( const char* pcCommandBuffer )
{
	int i;
	int iSpaceIndex;
	int iCommandBufferLength; 	// 처리할 커맨드 버퍼 길이.
	int iCommandLength;			// 등록된 커맨드 버퍼 길이.
	int iCount;					// 등록된 커맨드 개수.

	// 공백으로 구분된 커맨드를 추출
	iCommandBufferLength = kStrLen( pcCommandBuffer );
	for( iSpaceIndex = 0; iSpaceIndex < iCommandBufferLength; iSpaceIndex++)
	{
		if( pcCommandBuffer[iSpaceIndex] == ' ')
		{
			break;
		}
	}

	//커맨드 테이블을 검사해서 같은 이름의 커맨드가 있는지 확인.
	iCount = sizeof(gs_vstCommandTable) / sizeof(SHELLCOMMANDENTRY);
	for( i=0; i<iCount; i++ )
	{
		iCommandLength = kStrLen(gs_vstCommandTable[i].pcCommand);
		// 커맨드 길이와 내용이 완전히 일치하는지 검사 ( 위의 포문에서 iSpaceIndex로 입력 커맨드 길이를 갱신해놓음 )
		if( (iCommandLength == iSpaceIndex) &&
				(kMemCmp(gs_vstCommandTable[i].pcCommand, pcCommandBuffer, iSpaceIndex) == 0) )
		{
			// (pcCommandBuffer + iSpaceindex) 까지가 커맨드에 관한 위치 +1해서  그 뒤의 위치는 함수에 인자가 오게된다. 즉 인자를 읽기 위한 장치.
			gs_vstCommandTable[i].pfFunction( pcCommandBuffer + iSpaceIndex +1 );
			break;
		}
	}
	// 리스트에서 찾을 수 없다면 애러 출력.
	if( i >= iCount )
	{
		kPrintf("'%s' is not found.\n",pcCommandBuffer);
	}

}

// 파라미터 자료구조를 초기화
void kInitializeParameter( PARAMETERLIST* pstList, const char* pcParameter )
{
	pstList->pcBuffer = pcParameter;			// 파라미터의 시작주소.
	pstList->iLength = kStrLen(pcParameter);	// 전체 파라미터 길이
	pstList->iCurrentPosition = 0;				// 파라미터 시작 위치를 나타냄 (Offset)
}

// 공백으로 구분된 파라미터의 내용과 길이를 반환
int kGetNextParameter( PARAMETERLIST* pstList, char* pcParameter )
{
	int i;
	int iLength;

	// 처리할  파라미터가 없으면 나감
	if( pstList->iLength <= pstList->iCurrentPosition )
	{
		return 0;
	}
	// 처리할 파라미터가 있으면 버퍼의 길이만큼 이동하면서 공백을 검색( 공백을 통해 파라미터 구별 )
	for( i=pstList->iCurrentPosition; i<pstList->iLength; i++)
	{
		if(pstList->pcBuffer[i] == ' ')
		{
			break;
		}
	}

	// 파라미터를 복사하고 길이를 반환
	kMemCpy( pcParameter, pstList->pcBuffer+pstList->iCurrentPosition, i );
	iLength = i - pstList->iCurrentPosition;
	pcParameter[iLength ] = '\0';

	// 파라미터 위치 업데이트
	pstList->iCurrentPosition += iLength+1;
	return iLength;

}



// ===========================================================
// 커맨드를 처리하는 코드
// ===========================================================
// 셸 도움말을 출력
void kHelp( const char* pcCommandBuffer )
{
	int i;
	int iCount;
	int iCursorX, iCursorY;
	int iLength, iMaxCommandLength = 0;

	kPrintf("===============================================================\n");
	kPrintf("                       TestOS Shell Help                       \n");
	kPrintf("===============================================================\n");

	iCount = sizeof( gs_vstCommandTable) / sizeof(SHELLCOMMANDENTRY);

	// 가장 긴 커맨드의 길이를 계산  ( [커맨드    - 설명 ] 이런 구조로 출력할 건데 커맨드 최대 길이를 알아야 - 위치를 정할 수 있음으로
	for( i=0; i<iCount; i++)
	{
		iLength = kStrLen(gs_vstCommandTable[i].pcCommand );
		if( iLength > iMaxCommandLength )
		{
			iMaxCommandLength = iLength;
		}
	}

	// 도움말 출력
	for(i=0; i<iCount; i++)
	{
		kPrintf( "%s", gs_vstCommandTable[i].pcCommand );
		kGetCursor(&iCursorX, &iCursorY );
		kSetCursor( iMaxCommandLength, iCursorY );
		kPrintf(" - %s\n",gs_vstCommandTable[i].pcHelp );
	}

}


// 화면을 지움
void kCls( const char* pcParmeterBuffer )
{
	// 맨 윗줄은 디버깅 용으로 사용하므로 화면을 지운 후 라인 1로 커서 이동
	kClearScreen();
	kSetCursor(0, 1);
}


// 총 메모리 크기를 출력
void kShowTotalRAMSize( const char* pcParameterBuffer )
{
	kPrintf("Total RAM Size = %d MB\n",kGetTotalRAMSize() );
}


// 문자열로 된 숫자를 숫자로 변환하여 화면에 출력
void kStringToDecimalHexTest( const char* pcParameterBuffer )
{
	// pcParameterBuffer는 파라미터의 시작주소가 넘어온다.

	char vcParameter[100];	// 읽을 파라미터의 버퍼공간.
	int iLength;			// 파라미터의 길이
	PARAMETERLIST stList;	// 커맨드에 들어올 파라미터를 관리하는 구조체
	int iCount = 0;
	long lValue;

	// 파라미터 시작주소, 길이, 현재 파라미터 위치를 stList 구조체에 초기화.
	kInitializeParameter( &stList,  pcParameterBuffer );

	while(1)
	{
		// 다음 파라미터를 구함, 파라미터의 길이가 0이면 파라미터가 없는 것임으로 종료
		iLength = kGetNextParameter(&stList, vcParameter);

		// 파라미터 길이가  0이면  파라미터가 없으니깐 종료
		if(iLength == 0)
		{
			break;
		}

		// 파라미터가 있으니  파라미터에 대한 정보를 출력하고 16진수인지 10진수인지 판단하여 변환 후 결과를 kPrintf로 출력
		kPrintf("Param %d = '%s', Length = %d, ", iCount+1, vcParameter, iLength );
		// 0x로 시작하면 16진수, 그외는 10진수로...
		if( kMemCmp(vcParameter, "0x", 2) == 0 )
		{
			lValue = kAToI(vcParameter+2, 16);
			kPrintf("HEX value = %q\n",lValue);
		}
		else
		{
			lValue = kAToI(vcParameter, 10);
			kPrintf("Decimal Value = %d\n",lValue);
		}
		iCount++;
	}
}

// PC를 재시작
void kShutdown( const char* pcParameterBuffer )
{
	kPrintf("System Shutdown start...\n");

	// 키보드 컨트롤러를 통해 pc를 재시작
	kPrintf("Press Any Key To Reboot PC...\n");
	kGetCh();
	kReboot();
}

// PIT 컨트롤러의 카운터 0 설정
void kSetTimer( const char* pcParameterBuffer )
{
	char vcParameter[ 100 ];
	PARAMETERLIST stList;
	long lValue;
	BOOL bPeriodic;

	// 파라미터 초기화
	kInitializeParameter(&stList, pcParameterBuffer);

	// milisecond 추출
	if( kGetNextParameter(&stList, vcParameter) == 0 )
	{
		kPrintf(" ex)settimer 10(ms) 1(periodic)\n");
		return ;
	}
	lValue = kAToI( vcParameter,10);

	// Periodic 추출
	if( kGetNextParameter(&stList, vcParameter) == 0)
	{
		kPrintf("ex)settimer 10(ms) 1(periodic)\n");
		return;
	}
	bPeriodic = kAToI( vcParameter, 10);

	kInitializePIT(MSTOCOUNT(lValue), bPeriodic);
	kPirntf("Time = %d ms, Periodic = %d Change Complete\n", lValue, bPeriodic);
}


// PIT 컨트롤러를 직접 사용하여 ms 동안 대기
void kWaitUsingPIT( const char* pcParameterBuffer)
{
	char vcParameter[ 100 ];
	int iLength;
	PARAMETERLIST stList;
	long lMilisecond;
	int i;

	// 파라미터 초기화
	kInitializeParameter(&stList, pcParameterBuffer);

	if( kGetNextParameter(&stList, vcParameter) == 0 )
	{
		kPirntf("ex)wait 100(ms)\n");
		return;
	}
	lMilisecond = kAToI(pcParameterBuffer, 10);
	kPrintf("%d ms Sleep Start...\n",lMilisecond);

	// 인터럽트를 비활성화 하고 PIT 컨트롤러를 통해 직접 시간을 츨정
	kDisableInterrupt();
	for( i=0; i<lMilisecond/30; i++)
	{
		kWaitUsingDirectPIT(MSTOCOUNT(30));
	}
	kWaitUsingDirectPIT(MSTOCOUNT(lMilisecond%30));
	kEnableInterrupt();
	kPrintf("%d ms Sleep Complete\n", lMilisecond );

	// 타이머 복원
	kInitializePIT(MSTOCOUNT(1), TRUE);

}

// 타임 스탬프 카운터를 읽음
void kReadTimeStampCounter( const char* pcParameterBuffer)
{
	QWORD qwTSC;
	qwTSC = kReadTSC();
	kPrintf("time stamp Counter = %q\n",qwTSC);
}


// 프로세서의 속도를 측정
void kMeasureProcessorSpeed( const char* pcParameterBuffer)
{
	int i;
	QWORD qwLastTSC, qwTotalTSC = 0;

	kPrintf("Now Measuring.");

	// 10초 동안 변화한 타임 스탬프 카운터를 이용하여 프로세서의 속도를 간접적으로 측정
	kDisableInterrupt();
	for( i=0; i<200; i++)
	{
		qwLastTSC =kReadTSC();
		kWaitUsingDirectPIT(MSTOCOUNT(50));
		qwTotalTSC += kReadTSC() - qwLastTSC;

		kPrintf(".");
	}
	// 타이머 복원
	kInitializePIT(MSTOCOUNT(1),TRUE);
	kEnableInterrupt();

	kPrintf("\nCPU Speed = %d MHz\n",qwTotalTSC/10/1000/1000 );
}

// RTC 컨트롤러에 저장된 일자 및 시간 정보를 표시
void kShowDataAndTime( const char* pcParameterBuffer)
{
	BYTE bSecond, bMinute, bHour;
	BYTE bDayOfWeek, bDayOfMonth, bMonth;
	WORD wYear;

	// RTC 컨트롤러에서 시간 및 일자를 읽음
	kReadRTCTime(&bHour, &bMinute, &bSecond);
	kReadRTCDate(&wYear, &bMonth, &bDayOfMonth, &bDayOfWeek);

	kPrintf(" Date: %d/%d/%d %s, ",wYear,bMonth,bDayOfMonth,kConvertDayOfWeekToString(bDayOfWeek));
	kPritnf(" Time: %d:%d:%d]n",bHour,bMinute,bSecond);
}

















