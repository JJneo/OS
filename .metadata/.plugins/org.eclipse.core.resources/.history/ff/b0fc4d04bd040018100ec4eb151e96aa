/*
 * ConsoleShell.c
 *
 *  Created on: 2018. 1. 27.
 *      Author: Administrator
 */

#include "ConsoleShell.h"
#include "Console.h"
#include "Keyboard.h"
#include "Utility.h"


// 커맨드 테이블 정의
SHELLCOMMANDENTRY gs_vstCommandTable[] =
{
		{"help", "Show Help", kHelp },
		{"cls", "Clear Screen", "kCls" },
		{"totalram", "Show Total RAM Size", kShowTotalRAMSize},
		{"strtod","String to Decimal/Hex Convert", kStringToDecimalHexTest },
		{"shutdown", "Shutdown And ReBoot OS", kShutdown},
};

//===============================================================
// 실제 셸을 구성하는 코드
//===============================================================
// 셸의 메인 루프
void kStartConsoleShell(void)
{
	char vcCommandBuffer[ CONSOLESHELL_MAXCOMMANDBUFFERCOUNT ];
	int iCommandBufferIndex=0;
	BYTE bKey;
	int iCursorX, iCursorY;

	//프롬프트 출력
	kPrintf( CONSOLESHELL_PROMPTMESSAGE );

	while( 1 )
	{
		bKey = kGetCh();
		// Backspace 키 처리
		if( bKey == KEY_BACKSPACE )
		{
			if( iCommandBufferIndex > 0 )
			{
				// 현재 커서 위치를 얻어서 한 문자 앞으로 이동한 다음 공백을 출력하고 커맨드 버퍼에서 마지막 문자 삭제
				kGetCursor( &iCursorX, &iCursorY );
				kPrintStringXY(iCursorX-1, iCursorY, " ");
				kSetCursor( iCursorX-1,iCursorY);
				iCommandBufferIndex--;
			}
		}
		//엔터키 처리
		else if( bKey == KEY_ENTER )
		{
			if( iCommandBufferIndex > 0 )
			{
				// 커맨드 버퍼에 있는 명령을 실행
				vcCommandBuffer[ iCommandBufferIndex ] = '\0';		// 커맨드가 문자열로 저장되니 널문자를 삽입해줌.
				kExecuteCommand(vcCommandBuffer);

			}

			// 프롬프트 출력 및 커맨드 버퍼 초기화
			kPrintf( "%s", CONSOLESHELL_PROMPTMESSAGE);
			kMemSet( vcCommandBuffer,'\0',CONSOLESHELL_MAXCOMMANDBUFFERCOUNT);
			iCommandBufferIndex=0;
		}
		// shift, Caps Lock, Num Lock, Scroll Lock은 무시
		else if( (bKey == KEY_LSHIFT) || (bKey == KEY_RSHIFT) || (bKey == KEY_CAPSLOCK) ||
			     (bKey == KEY_NUMLOCK) || (bKey == KEY_SCROLLLOCK) )
		{
			;
		}
		else
		{
			//TAB은 공백으로 전환
			if( bKey == KEY_TAB )
			{
				bKey=' ';
			}
			// 버퍼에 공간이 남아 있을 때만 가능 ( 그외 문자는 커맨드 버퍼에 쑤셔넣음 )
			if( iCommandBufferIndex < CONSOLESHELL_MAXCOMMANDBUFFERCOUNT )
			{
				vcCommandBuffer[iCommandBufferIndex++] = bKey;
				kPrintf("%c",bKey);
			}
		}
	}
}


// 커맨드 버퍼에 있는 커맨드를 비교하여 해당 커맨드를 처리하는 함수를 수행
void kExecuteCommand( const char* pcCommandBuffer )
{
	int i;
	int iSpaceIndex;
	int iCommandBufferLength; 	// 처리할 커맨드 버퍼 길이.
	int iCommandLength;			// 등록된 커맨드 버퍼 길이.
	int iCount;					// 등록된 커맨드 개수.

	// 공백으로 구분된 커맨드를 추출
	iCommandBufferLength = kStrLen( pcCommandBuffer );
	for( iSpaceIndex = 0; iSpaceIndex < iCommandBufferLength; iSpaceIndex++)
	{
		if( pcCommandBuffer[iSpaceIndex] == ' ')
		{
			break;
		}
	}

	//커맨드 테이블을 검사해서 같은 이름의 커맨드가 있는지 확인.
	iCount = sizeof(gs_vstCommandTable) / sizeof(SHELLCOMMANDENTRY);
	for( i=0; i<iCount; i++ )
	{
		iCommandLength = kStrLen(gs_vstCommandTable[i].pcCommand);
		// 커맨드 길이와 내용이 완전히 일치하는지 검사 ( 위의 포문에서 iSpaceIndex로 입력 커맨드 길이를 갱신해놓음 )
		if( (iCommandLength == iSpaceIndex) &&
				(kMemcmp(gs_vstCommandTable[i].pcCommand, pcCommandBuffer, iSpaceIndex) == 0) )
		{
			// (pcCommandBuffer + iSpaceindex) 까지가 커맨드에 관한 위치 +1해서  그 뒤의 위치는 함수에 인자가 오게된다. 즉 인자를 읽기 위한 장치.
			gs_vstCommandTable[i].pfFunction( pcCommandBuffer + iSpaceIndex +1 );
			break;
		}
	}
	// 리스트에서 찾을 수 없다면 애러 출력.
	if( i >= iCount )
	{
		kPrintf("'%s' is not found.\n",pcCommandBuffer);
	}

}

// 파라미터 자료구조를 초기화
void kInitializeParameter( PARAMETERLIST* pstList, const char* pcParameter )
{
	pstList->pcBuffer = pcParameter;			// 파라미터의 시작주소.
	pstList->iLength = kStrLen(pcParameter);	// 전체 파라미터 길이
	pstList->iCurrentPosition = 0;				// 파라미터 시작 위치를 나타냄 (Offset)
}

// 공백으로 구분된 파라미터의 내용과 길이를 반환
int kGetNextParameter( PARAMETERLIST* pstList, char* pcParameter )
{
	int i;
	int iLength;

	// 처리할  파라미터가 없으면 나감
	if( pstList->iLength <= pstList->iCurrentPosition )
	{
		return 0;
	}
	// 처리할 파라미터가 있으면 버퍼의 길이만큼 이동하면서 공백을 검색( 공백을 통해 파라미터 구별 )
	for( i=pstList->iCurrentPosition; i<pstList->iLength; i++)
	{
		if(pstList->pcBuffer[i] == ' ')
		{
			break;
		}
	}

	// 파라미터를 복사하고 길이를 반환
	kMemCpy( pcParameter, pstList->pcBuffer+pstList->iCurrentPosition, i );
	iLength = i - pstList->iCurrentPosition;
	pcParameter[iLength ] = '\0';

	// 파라미터 위치 업데이트
	pstList->iCurrentPosition += iLength+1;
	return iLength;

}



// ===========================================================
// 커맨드를 처리하는 코드
// ===========================================================
// 셸 도움말을 출력
void kHelp( const char* pcCommandBuffer )
{
	int i;
	int iCount;
	int iCursorX, iCursorY;
	int iLength, iMaxCommandLength = 0;

	kPrintf("===============================================================\n");
	kPrintf("                       TestOS Shell Help                       \n");
	kPrintf("===============================================================\n");

	iCount = sizeof( gs_vstCommandTable) / sizeof(SHELLCOMMANDENTRY);

	// 가장 긴 커맨드의 길이를 계산  ( [커맨드    - 설명 ] 이런 구조로 출력할 건데 커맨드 최대 길이를 알아야 - 위치를 정할 수 있음으로
	for( i=0; i<iCount; i++)
	{
		iLength = kStrLen(gs_vstCommandTable[i].pcCommand );
		if( iLength > iMaxCommandLength )
		{
			iMaxCommandLength = iLength;
		}
	}

	// 도움말 출력
	for(i=0; i<iCount; i++)
	{
		kPrintf( "%s", gs_vstCommandTable[i].pcCommand );
		kGetCursor(&iCursorX, &iCursorY );
		kSetCursor( iMaxCommandLength, iCursorY );
		kPrintf(" - %s\n",gs_vstCommandTable[i].pcHelp );
	}

}


// 화면을 지움
void kCls( const char* pcParmeterBuffer )
{
	// 맨 윗줄은 디버깅 용으로 사용하므로 화면을 지운 후 라인 1로 커서 이동
	kClearScreen();
	kSetCursor(0, 1);
}


// 총 메모리 크기를 출력
void kShowTotalRAMSize( const char* pcParameterBuffer )
{
	kPrintf("Total RAM Size = %d MB\n",kGetTotalRAMSize() );
}


// 문자열로 된 숫자를 숫자로 변환하여 화면에 출력
void kStringToDecimalHexTest( const char* pcParameterBuffer )
{
	// pcParameterBuffer는 파라미터의 시작주소가 넘어온다.

	char vcParameter[100];	// 읽을 파라미터의 버퍼공간.
	int iLength;			// 파라미터의 길이
	PARAMETERLIST stList;	// 커맨드에 들어올 파라미터를 관리하는 구조체
	int iCount = 0;
	long lValue;

	// 파라미터 시작주소, 길이, 현재 파라미터 위치를 stList 구조체에 초기화.
	kInitializeParameter( &stList,  pcParameterBuffer );

	while(1)
	{
		// 다음 파라미터를 구함, 파라미터의 길이가 0이면 파라미터가 없는 것임으로 종료
		iLength = kGetNextParameter(&stList, vcParameter);

		// 파라미터 길이가  0이면  파라미터가 없으니깐 종료
		if(iLength == 0)
		{
			break;
		}

		// 파라미터가 있으니  파라미터에 대한 정보를 출력하고 16진수인지 10진수인지 판단하여 변환 후 결과를 kPrintf로 출력
		kPrintf("Param %d = '%s', Length = %d, ", iCount+1, vcParameter, iLength );
		// 0x로 시작하면 16진수, 그외는 10진수로...
		if( kMemCmp(vcParameter, "0x", 2) == 0 )
		{
			lValue = kAToI(vcParameter+2, 16);
			kPrintf("HEX value = %q\n",lValue);
		}
		else
		{
			lValue = kAToI(vcParameter, 10);
			kPrintf("Decimal Value = %d\n",lValue);
		}
		iCount++;
	}
}

// PC를 재시작
void kShutdown( const char* pcParameterBuffer )
{
	kPrintf("System Shutdown start...\n");

	// 키보드 컨트롤러를 통해 pc를 재시작
	kPrintf("Press Any Key To Reboot PC...\n");
	kGetCh();
	kReboot();
}




